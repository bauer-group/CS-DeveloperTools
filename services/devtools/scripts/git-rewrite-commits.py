#!/usr/bin/env python3
"""
git-rewrite-commits.py - Rewrite Commit Messages
Bereinigt Commit-Messages basierend auf konfigurierbaren Patterns.
"""

import os
import sys
import re
import tempfile
import argparse
from typing import Dict, List
from pathlib import Path

try:
    from git import Repo, Actor
except ImportError:
    print("Error: GitPython required. Install with: pip install gitpython")
    sys.exit(1)

# Farben
RED = '\033[0;31m'
GREEN = '\033[0;32m'
YELLOW = '\033[1;33m'
CYAN = '\033[0;36m'
NC = '\033[0m'
BOLD = '\033[1m'

# Vordefinierte Pattern-Sets
PATTERN_PRESETS = {
    "claude": [
        r"ðŸ¤–\s*Generated with\s*\[Claude Code\]\(https://claude\.com/claude-code\)\s*",
        r"Co-Authored-By:\s*Claude[^\n]*<noreply@anthropic\.com>\s*",
        r"Co-Authored-By:\s*Claude Opus[^\n]*<noreply@anthropic\.com>\s*",
        r"Co-Authored-By:\s*Claude Sonnet[^\n]*<noreply@anthropic\.com>\s*",
    ],
    "copilot": [
        r"Co-Authored-By:\s*GitHub Copilot[^\n]*\s*",
        r"Generated by GitHub Copilot\s*",
    ],
    "ai-all": [
        r"ðŸ¤–\s*Generated with\s*\[Claude Code\]\(https://claude\.com/claude-code\)\s*",
        r"Co-Authored-By:\s*Claude[^\n]*<noreply@anthropic\.com>\s*",
        r"Co-Authored-By:\s*Claude Opus[^\n]*<noreply@anthropic\.com>\s*",
        r"Co-Authored-By:\s*Claude Sonnet[^\n]*<noreply@anthropic\.com>\s*",
        r"Co-Authored-By:\s*GitHub Copilot[^\n]*\s*",
        r"Generated by GitHub Copilot\s*",
        r"Co-authored-by:\s*.*AI.*\s*",
    ],
    "empty-lines": [
        r"\n{3,}",  # Replace 3+ newlines with 2
    ],
}


def clean_message(msg: str, patterns: List[str]) -> str:
    """Remove patterns from commit message."""
    cleaned = msg

    for pattern in patterns:
        if pattern == r"\n{3,}":
            cleaned = re.sub(pattern, "\n\n", cleaned)
        else:
            cleaned = re.sub(pattern, "", cleaned, flags=re.IGNORECASE | re.MULTILINE)

    # Clean up excess whitespace
    cleaned = re.sub(r"\n{3,}", "\n\n", cleaned)
    cleaned = cleaned.strip()

    if cleaned and not cleaned.endswith("\n"):
        cleaned += "\n"

    return cleaned


def format_git_date(dt) -> str:
    """Format datetime for git environment."""
    ts = int(dt.timestamp())
    offset = dt.strftime("%z") or "+0000"
    return f"{ts} {offset}"


def analyze_commits(repo: Repo, branch: str, patterns: List[str]) -> Dict:
    """Analyze commits for matching patterns."""
    commits = list(repo.iter_commits(branch, topo_order=True, reverse=True))

    stats = {
        "total": len(commits),
        "matching": 0,
        "samples": []
    }

    for commit in commits:
        cleaned = clean_message(commit.message, patterns)
        if cleaned != commit.message:
            stats["matching"] += 1
            if len(stats["samples"]) < 5:
                stats["samples"].append({
                    "hash": commit.hexsha[:8],
                    "original": commit.message[:100],
                    "cleaned": cleaned[:100]
                })

    return stats


def rewrite_history(repo: Repo, branch: str, patterns: List[str], dry_run: bool = False) -> int:
    """Rewrite commits that match patterns."""
    commits = list(repo.iter_commits(branch, topo_order=True, reverse=True))

    if not commits:
        print(f"{YELLOW}Branch '{branch}' has no commits{NC}")
        return 0

    old2new: Dict[str, str] = {}
    rewritten = 0
    env_backup = dict(os.environ)

    try:
        for commit in commits:
            msg_cleaned = clean_message(commit.message, patterns)
            has_match = msg_cleaned != commit.message

            # Map parent commits if already rewritten
            new_parents = [old2new[p.hexsha] for p in commit.parents if p.hexsha in old2new]
            parent_changed = any(p.hexsha in old2new for p in commit.parents)

            # Skip if no changes needed
            if not has_match and not parent_changed:
                old2new[commit.hexsha] = commit.hexsha
                continue

            if has_match:
                rewritten += 1
                print(f"{CYAN}â†’{NC} {commit.hexsha[:8]}: pattern removed")

            if dry_run:
                old2new[commit.hexsha] = commit.hexsha
                continue

            # Set git environment
            author = Actor(commit.author.name, commit.author.email)
            committer = Actor(commit.committer.name, commit.committer.email)

            os.environ["GIT_AUTHOR_NAME"] = author.name
            os.environ["GIT_AUTHOR_EMAIL"] = author.email
            os.environ["GIT_COMMITTER_NAME"] = committer.name
            os.environ["GIT_COMMITTER_EMAIL"] = committer.email
            os.environ["GIT_AUTHOR_DATE"] = format_git_date(commit.authored_datetime)
            os.environ["GIT_COMMITTER_DATE"] = format_git_date(commit.committed_datetime)

            # Build commit-tree command
            args = ["git", "commit-tree", commit.tree.hexsha]
            for parent in new_parents:
                args += ["-p", parent]
            args += ["-m", msg_cleaned]

            # Create new commit
            new_hash = repo.git.execute(args).strip()
            old2new[commit.hexsha] = new_hash

    finally:
        os.environ.clear()
        os.environ.update(env_backup)

    # Update branch ref
    if not dry_run and commits:
        new_head = old2new[commits[-1].hexsha]
        repo.git.update_ref(f"refs/heads/{branch}", new_head)

    return rewritten


def main():
    parser = argparse.ArgumentParser(
        description="Rewrite commit messages to remove patterns",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Pattern Presets:
  claude      Remove Claude Code attribution
  copilot     Remove GitHub Copilot attribution
  ai-all      Remove all AI tool attributions
  empty-lines Clean up excess blank lines

Examples:
  # Analyze commits for Claude patterns
  git-rewrite-commits.py --analyze --preset claude

  # Remove Claude patterns (dry run)
  git-rewrite-commits.py --preset claude --dry-run

  # Remove Claude patterns from remote repo
  git-rewrite-commits.py https://github.com/org/repo.git --preset claude

  # Use custom pattern
  git-rewrite-commits.py -p "TICKET-\\d+:\\s*" --dry-run
        """
    )

    parser.add_argument(
        "repo",
        nargs="?",
        default=".",
        help="Repository path or URL (default: current directory)"
    )
    parser.add_argument(
        "-b", "--branch",
        default="main",
        help="Branch to process (default: main)"
    )
    parser.add_argument(
        "--preset",
        choices=list(PATTERN_PRESETS.keys()),
        help="Use predefined pattern set"
    )
    parser.add_argument(
        "-p", "--pattern",
        action="append",
        default=[],
        help="Custom regex pattern to remove (can be repeated)"
    )
    parser.add_argument(
        "-a", "--analyze",
        action="store_true",
        help="Only analyze, don't rewrite"
    )
    parser.add_argument(
        "-d", "--dry-run",
        action="store_true",
        help="Show what would be changed without modifying"
    )

    args = parser.parse_args()

    # Build pattern list
    patterns = []
    if args.preset:
        patterns.extend(PATTERN_PRESETS[args.preset])
    patterns.extend(args.pattern)

    if not patterns:
        print(f"{RED}[ERROR] No patterns specified. Use --preset or --pattern{NC}")
        parser.print_help()
        sys.exit(1)

    print()
    print(f"{BOLD}{CYAN}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—{NC}")
    print(f"{BOLD}{CYAN}â•‘                  Git Commit Rewriter                          â•‘{NC}")
    print(f"{BOLD}{CYAN}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•{NC}")
    print()

    # Clone if URL provided
    temp_dir = None
    repo_path = args.repo

    if args.repo.startswith("http") or args.repo.startswith("git@"):
        temp_dir = tempfile.mkdtemp(prefix="git_rewrite_")
        print(f"Cloning {args.repo} to {temp_dir}...")
        repo = Repo.clone_from(args.repo, temp_dir, branch=args.branch)
        repo_path = temp_dir
    else:
        repo_path = os.path.abspath(args.repo)
        if not Path(repo_path, ".git").exists():
            print(f"{RED}[ERROR] Not a git repository: {repo_path}{NC}")
            sys.exit(1)
        repo = Repo(repo_path)

    print(f"Repository: {repo_path}")
    print(f"Branch: {args.branch}")
    print(f"Patterns: {len(patterns)}")
    print()

    if args.analyze:
        print(f"{BOLD}Analyzing commits...{NC}")
        stats = analyze_commits(repo, args.branch, patterns)

        print()
        print(f"Total commits: {stats['total']}")
        print(f"Matching commits: {YELLOW}{stats['matching']}{NC}")

        if stats['samples']:
            print()
            print(f"{BOLD}Sample matches:{NC}")
            for sample in stats['samples']:
                print(f"  {CYAN}{sample['hash']}{NC}")
                print(f"    Before: {sample['original'][:60]}...")

    else:
        if args.dry_run:
            print(f"{YELLOW}DRY RUN MODE - No changes will be made{NC}")
            print()

        print(f"{BOLD}Rewriting commits...{NC}")
        count = rewrite_history(repo, args.branch, patterns, args.dry_run)

        print()
        print(f"{GREEN}âœ“ {count} commits rewritten{NC}")

        if count > 0 and not args.dry_run:
            print()
            print(f"{BOLD}Next steps:{NC}")
            if temp_dir:
                print(f"  1. Review: cd {temp_dir} && git log -5")
                print(f"  2. Push: git push origin {args.branch} --force")
            else:
                print(f"  1. Review: git log -5")
                print(f"  2. Push: git push --force")

            print()
            print(f"{YELLOW}WARNING: Force push required - this rewrites history!{NC}")


if __name__ == "__main__":
    main()
